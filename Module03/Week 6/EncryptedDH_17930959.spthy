theory EncryptedDH
begin

/* Signed Diffie-Hellman protocol, first attempt:
   A -> B : A, aenc_B{g^x}  (x fresh)
   B -> A : B, aenc_A{g^y, h(g^x)}  (y fresh)
   A -> B : A, aenc_B{h(g^y)}  */


/* ----------------- */
/* Equational theory */
/* ----------------- */

/* Load the built-in Diffie-Hellman, asymmetric encryption and hashing equational theories */
builtins: diffie-hellman, asymmetric-encryption, hashing



/* ------------------ */
/* Key infrastructure */
/* ------------------ */

rule GenKey:  // generate long-term key pair, publish the public key
   [ Fr(~kA) ] 
   -->
   [ !Key($A, ~kA),  // notation: !Fact = persistent fact, not consumed by rules
     !Pk($A, pk(~kA)),
     Out(pk(~kA)) ]


/*----------------*/
/* Protocol rules */
/*----------------*/

/* Question 1 here */



rule Init_1:
  let gxI = 'g'^~xI in            // g^x
    [ Fr(~xI),
      !Pk(b, pkB) ]
    --[]->
    [ Init_1($A, ~xI, gxI, pkB),
      Out(<$A, aenc(gxI, pkB)>) ]


rule Resp_1:
  let gyR = 'g'^~yR               // g^y
      gxI = adec(enc_gx, skB)     // g^x
      hgx = h(gxI)                // h(g^x)
  in
    [ Fr(~yR),
      In(<a, enc_gx>),
      !Key($B, skB),
      !Pk(a, pkA) ]
    --[]->
    [ Resp_1($B, ~yR, gyR, gxI, hgx, skB),
      Out(<$B, aenc(<gyR, hgx>, pkA)>)]


rule Init_2:
  let m = adec(enc_hgy, skA)      // adec(aenc(g^y, h(g^x))) = (g^y, h^(g^x))
      gy = fst(m)                 // g^y
      hgx = snd(m)                // h(g^x)
      gxy = gy^~xI                // (g^y)^x = g^xy
  in 
    [ Init_1($A, ~xI, gxI, pkB),
      !Key($A, skA),
      In(<b, enc_hgx>) ]
    --[ Eq(hgx, h(gxI)),
        FinishedI($A),
        SecretI($A, b, gxy) ]->
    [ Init_2($A, ~xI, gxI, pkB, hgx),
      Out(<$A, aenc(h(gy), pkB)>)]


rule Resp_2:
  let hgy = adec(enc_hgy, skB)      // adec(aenc(h(g^y))) = h(g^y)
      gxy = gxI^~yR                 // (g^x)^y = g^xy
  in 
    [ Resp_1($B, ~yR, gyR, gxI, hgx, skB),
      In(<a, enc_hgy>)]
    --[ Eq(hgy, h(gyR)),
        FinishedR($B),
        SecretR(a, $B, gxy) ]->
    [ Resp_2($B, ~yR, gyR, gxI, hgx, skB, hgy, gxy) ]


/* ---------- */
/* Key Reveal */
/* ---------- */

/* Question 2 here */



/* ---------- */
/* Restrictions */
/* ---------- */

restriction equality:
"All x y #i. Eq(x,y) @i ==> x = y"


/* ---------- */
/* Properties */
/* ---------- */

/* Executability checks */
lemma executableI:
exists-trace "Ex #i A. FinishedI(A) @ i & not (Ex #j B. Compromised(B)@j)"

lemma executableR:
exists-trace "Ex #i B. FinishedR(B) @ i & not (Ex #j B. Compromised(B)@j)"


/* Key secrecy:  (Question 3)
   in all traces, if a key is marked as secret between two uncompromised agents,
   then the attacker cannot learn it */

lemma key_secrecyI:
"All #i A B k.
 (SecretI(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"

lemma key_secrecyR:
"All #i A B k.
 (SecretR(A, B, k) @ i &
  not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
  ==> not (Ex #j. K(k) @ j)"



/* Key agreement:  (Question 4)
Please uncomment the following two lemmas for this question.
*/


/*
lemma agreementR:
"All #i A B k.
  (CommitR( B, A, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningI(A, B, k) @ j & j < i)"
*/

/*
lemma agreementI:
"All #i A B k.
  (CommitI(A, B, k) @ i &
   not ((Ex #l. Compromised(A) @ l) | (Ex #m. Compromised(B) @ m)))
   ==> (Ex #j. RunningR(B, A, k) @ j & j < i)"
*/

end



